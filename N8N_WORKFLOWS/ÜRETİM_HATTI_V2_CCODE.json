{
  "name": "√úRETƒ∞M HATTI V2 (C.CODE)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "tools/create_n8n_flow",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        240,
        300
      ],
      "id": "webhook-create-flow",
      "name": "TOOL_create_n8n_flow",
      "webhookId": "b145b66e-4470-419c-a0a2-83b4aa5c206d"
    },
    {
      "parameters": {
        "jsCode": "// Parse incoming webhook request\nconst req = $input.first().json;\nconst body = req.body || {};\nconst desc = (body.description || 'No description').toLowerCase();\nconst name = body.workflowName || 'ARGUS auto: ' + desc.slice(0, 30);\n\nreturn [{\n  json: {\n    operation: 'GET',\n    taskDescription: desc,\n    workflowName: name\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        300
      ],
      "id": "parse-request",
      "name": "Parse Request"
    },
    {
      "parameters": {
        "workflowId": "{{ Add ARGUS_MEMORY_CORE workflow ID here after import }}",
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        680,
        300
      ],
      "id": "get-argus-memory",
      "name": "GET ARGUS_MEMORY"
    },
    {
      "parameters": {
        "jsCode": "// =================================================================\n// C.CODE WORKFLOW BUILDER\n// =================================================================\n// You are C.CODE. You do NOT design products. You ONLY write code.\n// This builder generates n8n workflow JSON based on:\n// - ARGUS_MEMORY (system context and rules)\n// - TASK_DESCRIPTION (concrete workflow requirements)\n// =================================================================\n\nconst memoryData = $('GET ARGUS_MEMORY').first().json.memory || {};\nconst taskData = $('Parse Request').first().json;\nconst desc = taskData.taskDescription;\nconst name = taskData.workflowName;\n\n// === HELPER FUNCTIONS ===\nfunction generateId() {\n  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\n\nfunction getTypeVersion(type) {\n  const versions = {\n    'n8n-nodes-base.httpRequest': 4.3,\n    'n8n-nodes-base.code': 2,\n    'n8n-nodes-base.set': 3.4,\n    'n8n-nodes-base.sort': 1,\n    'n8n-nodes-base.limit': 1,\n    'n8n-nodes-base.manualTrigger': 1,\n    'n8n-nodes-base.scheduleTrigger': 1.3,\n    'n8n-nodes-base.gmail': 2.1,\n    'n8n-nodes-base.gmailTrigger': 1.3,\n    'n8n-nodes-base.executeWorkflow': 1.3\n  };\n  return versions[type] || 1;\n}\n\nfunction createNode(type, nodeName, position, parameters, extras = {}) {\n  const node = {\n    parameters,\n    type,\n    typeVersion: getTypeVersion(type),\n    position,\n    id: extras.id || generateId(),\n    name: nodeName\n  };\n  if (extras.credentials) node.credentials = extras.credentials;\n  if (extras.webhookId) node.webhookId = extras.webhookId;\n  return node;\n}\n\nfunction addConnection(connections, fromNode, toNode) {\n  if (!connections[fromNode]) {\n    connections[fromNode] = { main: [[]] };\n  }\n  connections[fromNode].main[0].push({ node: toNode, type: 'main', index: 0 });\n}\n\n// === PATTERN DETECTION (DATA PROCESSING ONLY - NO AI CONTENT GENERATION) ===\nconst isScheduled = /her (g√ºn|saat|dakika|hafta)|g√ºnl√ºk|saatlik|zamanlanmƒ±≈ü|cron|\\d{1,2}:\\d{2}/i.test(desc);\nconst isCrypto = /bitcoin|btc|eth|ethereum|kripto|coin|fiyat.*kontrol|price.*check/i.test(desc);\nconst isTelegram = /telegram|mesaj g√∂nder|bildirim|notify/i.test(desc);\nconst isTwilio = /ara|arama|twilio|telefon|sesli|call/i.test(desc);\nconst isYouTube = /youtube|video.*trend|pop√ºler.*video|trending.*video/i.test(desc);\nconst isInstagram = /instagram|reel|story|post/i.test(desc);\nconst isGmail = /mail|e-posta|gmail|inbox/i.test(desc);\n\n// REMOVED: needsAI, needsVideoGeneration - C.CODE generates workflows, not content\n\nlet nodes = [];\nlet connections = {};\nlet currentX = 240;\nconst Y = 300;\nconst SPACING = 220;\n\n// === TRIGGER NODE ===\nlet triggerNode;\nif (isGmail && !isScheduled) {\n  triggerNode = createNode('n8n-nodes-base.gmailTrigger', 'Gmail Trigger', [currentX, Y], {\n    pollTimes: { item: [{ mode: 'everyMinute' }] },\n    filters: {}\n  }, { credentials: { gmailOAuth2: { id: '4m3aMGjLm89egLIv', name: 'Gmail account 2' } } });\n} else if (isScheduled) {\n  let cronExpression = '0 9 * * *';\n  const hourMatch = desc.match(/(\\d{1,2}):(\\d{2})/);\n  if (hourMatch) {\n    cronExpression = `${hourMatch[2]} ${hourMatch[1]} * * *`;\n  } else if (/her saat/i.test(desc)) {\n    cronExpression = '0 * * * *';\n  } else if (/her (\\d+) dakika/i.test(desc)) {\n    const minutes = desc.match(/her (\\d+) dakika/i)[1];\n    cronExpression = `*/${minutes} * * * *`;\n  }\n  triggerNode = createNode('n8n-nodes-base.scheduleTrigger', 'Schedule Trigger', [currentX, Y], {\n    rule: { interval: [{ field: 'cronExpression', expression: cronExpression }] }\n  });\n} else {\n  triggerNode = createNode('n8n-nodes-base.manualTrigger', \"When clicking 'Execute workflow'\", [currentX, Y], {});\n}\n\nnodes.push(triggerNode);\nlet previousNodeName = triggerNode.name;\ncurrentX += SPACING;\n\n// === YOUTUBE WORKFLOW (DATA ONLY - NO AI ANALYSIS) ===\nif (isYouTube) {\n  // 1. YouTube API Call\n  const youtubeNode = createNode('n8n-nodes-base.httpRequest', 'YouTube API - Get Videos', [currentX, Y], {\n    method: 'GET',\n    url: 'https://www.googleapis.com/youtube/v3/videos',\n    sendQuery: true,\n    queryParameters: {\n      parameters: [\n        { name: 'chart', value: 'mostPopular' },\n        { name: 'regionCode', value: 'TR' },\n        { name: 'maxResults', value: '20' },\n        { name: 'part', value: 'snippet,statistics' },\n        { name: 'key', value: '={{$env.YOUTUBE_API_KEY}}' }\n      ]\n    },\n    options: { response: { response: { responseFormat: 'json' } } }\n  });\n  nodes.push(youtubeNode);\n  addConnection(connections, previousNodeName, youtubeNode.name);\n  previousNodeName = youtubeNode.name;\n  currentX += SPACING;\n\n  // 2. Split Items\n  const splitNode = createNode('n8n-nodes-base.code', 'Split Video Items', [currentX, Y], {\n    jsCode: `const items = $json.items || [];\nreturn items.map(item => ({ json: item }));`\n  });\n  nodes.push(splitNode);\n  addConnection(connections, previousNodeName, splitNode.name);\n  previousNodeName = splitNode.name;\n  currentX += SPACING;\n\n  // 3. Set Fields\n  const setNode = createNode('n8n-nodes-base.set', 'Extract Video Data', [currentX, Y], {\n    assignments: {\n      assignments: [\n        { id: generateId(), name: 'title', value: '={{$json.snippet.title}}', type: 'string' },\n        { id: generateId(), name: 'channel', value: '={{$json.snippet.channelTitle}}', type: 'string' },\n        { id: generateId(), name: 'description', value: '={{$json.snippet.description}}', type: 'string' },\n        { id: generateId(), name: 'viewCount', value: '={{Number($json.statistics.viewCount) || 0}}', type: 'number' },\n        { id: generateId(), name: 'likeCount', value: '={{Number($json.statistics.likeCount) || 0}}', type: 'number' },\n        { id: generateId(), name: 'commentCount', value: '={{Number($json.statistics.commentCount) || 0}}', type: 'number' },\n        { id: generateId(), name: 'videoId', value: '={{$json.id}}', type: 'string' }\n      ]\n    },\n    options: {}\n  });\n  nodes.push(setNode);\n  addConnection(connections, previousNodeName, setNode.name);\n  previousNodeName = setNode.name;\n  currentX += SPACING;\n\n  // 4. Calculate Score (DATA PROCESSING - NOT AI)\n  const scoreNode = createNode('n8n-nodes-base.code', 'Calculate Engagement Score', [currentX, Y], {\n    jsCode: `const views = $json.viewCount || 0;\nconst likes = $json.likeCount || 0;\nconst comments = $json.commentCount || 0;\n\nconst engagementRate = views > 0 ? ((likes + comments) / views) * 100 : 0;\nconst score = (views * 0.5) + (likes * 30) + (comments * 50) + (engagementRate * 1000);\n\nreturn [{\n  json: {\n    ...$json,\n    engagementRate: engagementRate.toFixed(2),\n    score: Math.round(score)\n  }\n}];`\n  });\n  nodes.push(scoreNode);\n  addConnection(connections, previousNodeName, scoreNode.name);\n  previousNodeName = scoreNode.name;\n  currentX += SPACING;\n\n  // 5. Sort by Score\n  const sortNode = createNode('n8n-nodes-base.sort', 'Sort by Score', [currentX, Y], {\n    sortFieldsUi: {\n      sortField: [{ fieldName: 'score', order: 'descending' }]\n    }\n  });\n  nodes.push(sortNode);\n  addConnection(connections, previousNodeName, sortNode.name);\n  previousNodeName = sortNode.name;\n  currentX += SPACING;\n\n  // 6. Limit to Top 3\n  const limitNode = createNode('n8n-nodes-base.limit', 'Top 3 Videos', [currentX, Y], {\n    maxItems: 3\n  });\n  nodes.push(limitNode);\n  addConnection(connections, previousNodeName, limitNode.name);\n  previousNodeName = limitNode.name;\n  currentX += SPACING;\n\n  // 7. Format Results (DATA ONLY - NO AI CONTENT GENERATION)\n  const formatNode = createNode('n8n-nodes-base.code', 'Format Results', [currentX, Y], {\n    jsCode: `const items = $input.all();\nlet message = 'üé¨ YouTube Trending Videos (Data Analysis):\\\\n\\\\n';\n\nitems.forEach((item, i) => {\n  const title = item.json.title || '-';\n  const channel = item.json.channel || '-';\n  const views = item.json.viewCount || 0;\n  const score = item.json.score || 0;\n  const engagement = item.json.engagementRate || '0.00';\n\n  message += \\`üìπ \\${i+1}. \\${title}\\\\n\\`;\n  message += \\`   üë§ Channel: \\${channel}\\\\n\\`;\n  message += \\`   üëÅÔ∏è Views: \\${views.toLocaleString()}\\\\n\\`;\n  message += \\`   ‚≠ê Score: \\${score}\\\\n\\`;\n  message += \\`   üí¨ Engagement: \\${engagement}%\\\\n\\\\n\\`;\n});\n\nreturn [{ json: { message } }];`\n  });\n  nodes.push(formatNode);\n  addConnection(connections, previousNodeName, formatNode.name);\n  previousNodeName = formatNode.name;\n  currentX += SPACING;\n\n  // 8. Telegram Notification\n  const telegramNode = createNode('n8n-nodes-base.httpRequest', 'Send to Telegram', [currentX, Y], {\n    method: 'POST',\n    url: '=https://api.telegram.org/bot{{$env.TELEGRAM_BOT_TOKEN}}/sendMessage',\n    sendBody: true,\n    bodyParameters: {\n      parameters: [\n        { name: 'chat_id', value: '1496380263' },\n        { name: 'text', value: '={{$json.message}}' }\n      ]\n    },\n    options: {}\n  });\n  nodes.push(telegramNode);\n  addConnection(connections, previousNodeName, telegramNode.name);\n  previousNodeName = telegramNode.name;\n  currentX += SPACING;\n}\n\n// === INSTAGRAM WORKFLOW (DATA ONLY - NO AI CONTENT GENERATION) ===\nelse if (isInstagram) {\n  // Instagram API integration would go here\n  // For now, just create a placeholder\n  const placeholderNode = createNode('n8n-nodes-base.code', 'Instagram Data Processor', [currentX, Y], {\n    jsCode: `return [{ json: { message: 'Instagram workflow: Data processing only. No AI content generation as per C.CODE rules.' } }];`\n  });\n  nodes.push(placeholderNode);\n  addConnection(connections, previousNodeName, placeholderNode.name);\n  previousNodeName = placeholderNode.name;\n  currentX += SPACING;\n}\n\n// === GMAIL WORKFLOW (DATA ONLY - NO AI SUMMARIZATION) ===\nelse if (isGmail) {\n  const getMessageNode = createNode('n8n-nodes-base.gmail', 'Get Email', [currentX, Y], {\n    operation: 'get',\n    messageId: '={{ $json.id }}',\n    simple: false,\n    options: {}\n  }, { credentials: { gmailOAuth2: { id: '4m3aMGjLm89egLIv', name: 'Gmail account 2' } } });\n  nodes.push(getMessageNode);\n  addConnection(connections, previousNodeName, getMessageNode.name);\n  previousNodeName = getMessageNode.name;\n  currentX += SPACING;\n\n  // Format email data (NO AI SUMMARIZATION)\n  const formatNode = createNode('n8n-nodes-base.code', 'Format Email Data', [currentX, Y], {\n    jsCode: `const subject = $json.subject || '-';\nconst from = $json.from?.value?.[0]?.address || '-';\nconst snippet = $json.snippet || '-';\nconst date = $json.internalDate || '-';\n\nconst message = 'üìß New Email:\\\\n' +\n  'üë§ From: ' + from + '\\\\n' +\n  'üìå Subject: ' + subject + '\\\\n' +\n  'üìÖ Date: ' + new Date(parseInt(date)).toLocaleString() + '\\\\n' +\n  'üìÑ Preview: ' + snippet;\n\nreturn [{ json: { message } }];`\n  });\n  nodes.push(formatNode);\n  addConnection(connections, previousNodeName, formatNode.name);\n  previousNodeName = formatNode.name;\n  currentX += SPACING;\n}\n\n// === CRYPTO WORKFLOW (DATA ONLY) ===\nelse if (isCrypto) {\n  const cryptoId = /bitcoin|btc/i.test(desc) ? 'bitcoin' : 'ethereum';\n  const cryptoName = cryptoId === 'bitcoin' ? 'BTC' : 'ETH';\n\n  const fetchNode = createNode('n8n-nodes-base.httpRequest', 'Fetch Crypto Price', [currentX, Y], {\n    method: 'GET',\n    url: `https://api.coingecko.com/api/v3/simple/price?ids=${cryptoId}&vs_currencies=try`,\n    options: { response: { response: { responseFormat: 'json' } } }\n  });\n  nodes.push(fetchNode);\n  addConnection(connections, previousNodeName, fetchNode.name);\n  previousNodeName = fetchNode.name;\n  currentX += SPACING;\n\n  const processNode = createNode('n8n-nodes-base.code', 'Process Price Data', [currentX, Y], {\n    jsCode: `const data = $json;\nconst cryptoName = Object.keys(data)[0];\nconst price = data[cryptoName].try;\nconst message = 'üí∞ ' + cryptoName.toUpperCase() + ' Price: ' + Number(price).toLocaleString('tr-TR') + ' TL';\nreturn [{ json: { message, price, cryptoName } }];`\n  });\n  nodes.push(processNode);\n  addConnection(connections, previousNodeName, processNode.name);\n  previousNodeName = processNode.name;\n  currentX += SPACING;\n}\n\n// === TWILIO CALL ===\nif (isTwilio) {\n  const twilioDataNode = createNode('n8n-nodes-base.code', 'Prepare Twilio Data', [currentX, Y], {\n    jsCode: `const to = process.env.ALERT_TARGET_NUMBER || '+905454423820';\nconst from = process.env.TWILIO_PHONE_NUMBER || '+127223344653';\nconst messageText = $json.message || 'ARGUS Notification';\nconst webhookUrl = 'https://argusbot.duckdns.org/webhook/argus_voice_agent';\n\nconst twiml = \\`\n<Response>\n  <Gather input=\"speech\" language=\"tr-TR\" method=\"POST\" action=\"\\${webhookUrl}\">\n    <Say language=\"tr-TR\">\\${messageText}</Say>\n  </Gather>\n</Response>\n\\`.trim();\n\nreturn [{ json: { to, from, twiml } }];`\n  });\n  nodes.push(twilioDataNode);\n  addConnection(connections, previousNodeName, twilioDataNode.name);\n  previousNodeName = twilioDataNode.name;\n  currentX += SPACING;\n\n  const twilioCallNode = createNode('n8n-nodes-base.httpRequest', 'Twilio Call', [currentX, Y], {\n    method: 'POST',\n    url: '=https://api.twilio.com/2010-04-01/Accounts/{{$env.TWILIO_ACCOUNT_SID}}/Calls.json',\n    authentication: 'genericCredentialType',\n    genericAuthType: 'httpBasicAuth',\n    sendBody: true,\n    contentType: 'raw',\n    rawContentType: '=application/x-www-form-urlencoded',\n    body: `={{ 'To=' + encodeURIComponent($json.to) + '&From=' + encodeURIComponent($json.from) + '&Twiml=' + encodeURIComponent($json.twiml) }}`,\n    options: {}\n  }, { credentials: { httpBasicAuth: { id: 'Tn2UknHXfLcUtpyN', name: 'Twilio Credentials' } } });\n  nodes.push(twilioCallNode);\n  addConnection(connections, previousNodeName, twilioCallNode.name);\n  previousNodeName = twilioCallNode.name;\n  currentX += SPACING;\n}\n\n// === TELEGRAM NOTIFICATION ===\nif (isTelegram && !isYouTube) {\n  const telegramNode = createNode('n8n-nodes-base.httpRequest', 'Send Telegram', [currentX, Y], {\n    method: 'POST',\n    url: '=https://api.telegram.org/bot{{$env.TELEGRAM_BOT_TOKEN}}/sendMessage',\n    sendBody: true,\n    bodyParameters: {\n      parameters: [\n        { name: 'chat_id', value: '1496380263' },\n        { name: 'text', value: '={{$json.message || \"ARGUS Notification\"}}' }\n      ]\n    },\n    options: {}\n  });\n  nodes.push(telegramNode);\n  addConnection(connections, previousNodeName, telegramNode.name);\n  previousNodeName = telegramNode.name;\n  currentX += SPACING;\n}\n\n// === FALLBACK ===\nif (nodes.length === 1) {\n  const fallbackNode = createNode('n8n-nodes-base.code', 'Process Data', [currentX, Y], {\n    jsCode: `return [{ json: { \n      message: 'Workflow created successfully (C.CODE mode - data processing only)',\n      description: '${desc}',\n      argusMemory: ${JSON.stringify(memoryData)}\n    } }];`\n  });\n  nodes.push(fallbackNode);\n  addConnection(connections, previousNodeName, fallbackNode.name);\n}\n\n// === BUILD WORKFLOW ===\nconst apiWorkflow = {\n  name,\n  nodes,\n  connections,\n  settings: { \n    executionOrder: 'v1',\n    timezone: 'Europe/Istanbul'\n  },\n  meta: {\n    generatedBy: 'C.CODE',\n    argusMemoryVersion: memoryData.last_updated || 'v1',\n    rules: 'No AI content generation - data processing only'\n  }\n};\n\nreturn [{ json: { apiWorkflow, argusMemory: memoryData } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        300
      ],
      "id": "ccode-workflow-builder",
      "name": "C.CODE WORKFLOW BUILDER"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://127.0.0.1:5678/api/v1/workflows",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{$env.N8N_API_KEY}}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.apiWorkflow) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1120,
        300
      ],
      "id": "n8n-api-create",
      "name": "n8n API - Create Workflow"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first().json;\nconst data = item.data || item;\n\nif (!data || !data.id) {\n  return [{ json: { ok: false, error: item.message || 'Workflow creation failed', raw: item } }];\n}\n\nreturn [{ json: { \n  ok: true, \n  workflowId: data.id, \n  name: data.name, \n  generatedBy: 'C.CODE',\n  reply: `‚úÖ Workflow created: ${data.name}\\nID: ${data.id}\\nMode: C.CODE (data processing only)` \n} }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        300
      ],
      "id": "response-builder",
      "name": "Response Builder"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        1560,
        300
      ],
      "id": "webhook-response",
      "name": "Respond to Webhook"
    }
  ],
  "pinData": {},
  "connections": {
    "TOOL_create_n8n_flow": {
      "main": [
        [
          {
            "node": "Parse Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Request": {
      "main": [
        [
          {
            "node": "GET ARGUS_MEMORY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET ARGUS_MEMORY": {
      "main": [
        [
          {
            "node": "C.CODE WORKFLOW BUILDER",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "C.CODE WORKFLOW BUILDER": {
      "main": [
        [
          {
            "node": "n8n API - Create Workflow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "n8n API - Create Workflow": {
      "main": [
        [
          {
            "node": "Response Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response Builder": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timezone": "Europe/Istanbul",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "ccode-builder-v2",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "b3095fc29cb871b1a1fa62649bfd13016a8a983bdcd4a1523275b8f83ce36cce",
    "generatedBy": "C.CODE",
    "description": "Refactored builder with ARGUS_MEMORY integration and no AI content generation"
  },
  "id": "0OvLyVNV4rEQp2qz",
  "tags": []
}
